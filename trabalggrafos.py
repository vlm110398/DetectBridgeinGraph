# -*- coding: utf-8 -*-
"""TrabAlgGrafos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17LeQ7te0i9fPL0mgp6sZaRldABscYxFv

Nome: Algoritmo de detecção de pontes

Entrada: Um grafo qualquer (pode ser desconexo)

Saída: Listagem de Arestas com classificação e dizendo se este é ponte e listagem da lista de adjacências com valores finais de low e pe

Complexidade: (V+E) especificada no trabalho manuscrito

Para rodar o programa clique na aba superior Runtime e após isso Run all
"""

class Vertex:
  
  # constructor
  def __init__(self,index):
    self.pointer_position = 0  # posicao do ponteiro da sua adjacencia 
    self.color = 0             # cor
    self.index = index         # id
    self.pe = -1               # entrada na pilha
    self.ps = -1               # saida da pilha
    self.father = self         # pai
    self.neighbor = []         # vizinhos é cada indice é um dicionário no formato {vertex : vertice , edge_visited : booleano para saber se a aresta ja foi visitada}
    self.low = 0
  # retorna id do vertice como string
  def __rep__(self):
    return str(self.index)

class Graph:
  # constructor
  def __init__(self, digraph = False):
    self.digraph = digraph
    self.adj_list = []
  
  # busca em profundidade (Algoritmo Geral de Busca) e ao final imprime as pontes
  def DFS(self): #s é a raiz e um objeto do tipo Vertex
    pre_order = [] #lista dos vertices que entram na pilha em ordem 
    post_order = [] #lista dos vertices que saem da pilha em ordem
    m = [] #estrutura de dados usada (para DFS pilha)
    r = [] #candidatos a raizes das arvores de profundidade
    pe = -1 # ordem temporal que o vertice entra na pilha
    ps = -1 # ordem temporal que o vertice sai da pilha
    for u in self.adj_list: #para todo vértice o torna branco (não vistiado)
      u.color = 0  #cor branca (não visitado)
      r.append(u)  #por todos os vertices na lista de candidatos à raízes
    for s in r: # para cada vertice de r
      if(s.color == 0): #se não estiver visitado
        s.color = 1 # a raiz é cinza (está sendo visitada)
        s.pe = pe = pe+1 #adiciona pe de s uma unidade
        m.append(s) #coloca na pilha
        s.low = s.pe = pe = pe+1    #marca o seu low com o seu pe
        pre_order.append(s) # coloca s em pre_order
      else: # se já foi visitado então não pode ser um candidato à raiz
        r.remove(s) # remove s de r
        continue    #pula iteração do loop
      while(len(m) != 0):
        u = m[0] # pego o topo da pilha
        all_edges_visited = True # booleana para saber se todas as arestas já foram visitadas, se existir pelo menos uma então vai ser False, se nenhuma for continuará como True 
        for i in range(u.pointer_position,len(u.neighbor)): #Fazemos o for em relação ao ponteiro de cada vértice até o final de seus vértices adjacentes, justamente para não estragar a complexidade (visitar todos os vizinhos uma só vez)
          u.pointer_position = i #Atualizamos o ponteiro em relação ao i do for
          v = u.neighbor[u.pointer_position]['vertex'] # Só para escrever menos , é o vertice pego dos adjacentes de u
          if(u.neighbor[u.pointer_position]['edge_visited'] == False): #Se a aresta não for visitada
            all_edges_visited = False                 #Tornamos a booleana False
            u.neighbor[i]['edge_visited'] = True      #Marcamos esta como visitada
            if(v.color == 0): #Se o vertice visitado for branco
              m.insert(0, v)  #Colocamos-o na pilha 
              pre_order.append(v) #Colocamos-o no pre_order
              v.color = 1         #Marcamos-o como visitado (Cinza)
              v.father = u        #Colocamos o seu pai na struct
              v.low = v.pe = pe = pe + 1  #Marcamos o tempo de entrada dele em M
              print(u.__rep__() + " " +  v.__rep__() + " Visit1: Tree Edge " ) #Printamos o seu visite 1 e qual o seu tipo de aresta
              u.pointer_position = u.pointer_position + 1   #Movemos o ponteiro do vertice em uma unidade
            else:        #Senão está sendo visitado pela primeira vez
              print(u.__rep__() + " " +  v.__rep__() + " Visit:2 ", end = '' )  #Printamos seu Visite2
              if(self.digraph == True): #Se for um digrafo tem as seguintes classificações
                if(v.color == 1): # Se v é cinza (já visitado)
                    print("Back Edge ") #Sou aresta de retorno
                elif(v.color == 2): #Se a cor do vertice for preta (explorado)
                  if(v.pe > u.pe):  #v.pe > u.pe
                    print("Foward Edge") #Sou aresta de avanço
                  else:
                    print("Cross Edge")  #Sou aresta de Cruzamento

              else: #G não é um digrafo
                if(v.color == 1 and  v.pe < u.pe): #Se v já foi visitado
                    if(u.father == v):         #Pai de u é v
                      print("Repeat of Tree Edge") #Segundo print da aresta de árvore
                    else:
                      print("Back Edge ")  #Primeiro print da aresta de retorno
                      if(v.low < u.low): #Se low(v) < low(u)
                        u.low = v.low     #low(u) = low(v)
                elif(v.color == 2): #Se a cor do vertice for preta (explorado)
                  if(v.pe > u.pe): # Repeticao da aresta de retorno 
                    print("Repeat of Back Edge") #Segundo print da aresta de retorno
              u.pointer_position = u.pointer_position + 1 #Atualizo o ponteiro do vértice para percorrer sua lista de vértices vizinhos apenas uma vez 
            break #Se eu sou uma aresta não visitada quebro o for ao achá-la       
        if(all_edges_visited == True): #Se não achei nenhuma aresta não visitada
          u.color = 2  # Vértice preto agora, (explorado)
          m.pop(0)     #Tiro-o da pilha (Dou pop no topo)
          post_order.append(u)  # Boto o vértice no post_order
          u.ps = ps = ps + 1 # Marco o seu tempo de saída de M
          for k in u.neighbor: # Para cada vizinho de u
            v = k['vertex'] # Pegar o vertice
            if(v.father == u): # Se o pai de v é u
              if( u.pe < v.low): #Se pe(u) < low(v) 
                print(u.__rep__() + " " + v.__rep__() + " Sou aresta de ponte")
              if(v.low < u.low): #Se low(v) < low(u) 
                u.low = v.low    # low(u) = low(v)
            

#_______________________________________________END OF BFS(V+E)_____________________________________________________________________________________
    print("")
    print("Pre Order: (Ordem de entrada na pilha)") #Print dos vértices do pre_order ordem crescente de PE O(V)
    for vertex in pre_order:
      print(vertex.__rep__() + " ", end = '') 
    print("")
    print("Post Order (Ordem de saída da pilha)") #Print dos vértices do post_order ordem crescente de PS O(V)
    for vertex in post_order:
      print(vertex.__rep__() + " ", end = '')
    print("")  

    
    
  # adiciona vertice para lista de adjacencias
  def add_vertex(self):
    index = len(self.adj_list)
    u = Vertex(index)
    self.adj_list.append(u)
    print("Vertex: " + self.adj_list[-1].__rep__() + " created")
  
  # retorna o vertice (objeto da classe Vertex) de index da lista de adj
  def vertex(self, index):
    if(index < len(list(self.adj_list))):
      #print(self.adj_list[index].__rep__())
      return self.adj_list[index]
    else:
      print("The vertex " + str(index) + " is not exists in adj list")
      return []
    
  #cria aresta entre u e v
  def connect_vertex(self,u,v):
    if(type(u) == list or type(v) == list ):
      return False
    if(u == v):
      print("Not multigraph, the vertex don't connect with himself.")
      return False 
    for item in v.neighbor:
      if(item['vertex'] == u):
        print(v.__rep__() + " already is connected with "+ u.__rep__())
        return False
    u.neighbor.append({'vertex' : v, 'edge_visited' : False})
    
    print("New edge is created " + u.__rep__() + " --> "+ v.__rep__())
    if(self.digraph == False):
      for item in v.neighbor:
        if(item['vertex'] == u):
          print(v.__rep__ + " already is connected with "+ u.__rep__)
          return False
      v.neighbor.append({'vertex': u, 'edge_visited' : False})
      print("New edge is created " + v.__rep__() + " --> "+ u.__rep__())
    return True
  
  
  #printa a lista de adjacência e se a aresta já foi visitada
  def print(self):
    print("")
    for u in self.adj_list:
      print(u.__rep__() + " (" + "Low:" + str(u.low) + " PE:" + str(u.pe) +  ") --> ", end='')
      for v in u.neighbor:
        print(" "+v['vertex'].__rep__(), end='')
      print("")
    print("")

"""Exemplo 1: Grafo da figura indicada em:
https://images.app.goo.gl/uZ58qBZ5TAM2XpBt7
"""

g = Graph(digraph = False)
g.add_vertex() 
g.add_vertex()
g.add_vertex()
g.add_vertex()
g.add_vertex()
g.add_vertex()
g.add_vertex()
g.add_vertex()
g.add_vertex()
g.add_vertex()
g.add_vertex() 
g.add_vertex()
g.add_vertex()
g.add_vertex()
g.add_vertex()
g.add_vertex()
g.connect_vertex(g.vertex(0), g.vertex(1))
g.connect_vertex(g.vertex(3), g.vertex(4))
g.connect_vertex(g.vertex(3), g.vertex(5))
g.connect_vertex(g.vertex(4), g.vertex(5))
g.connect_vertex(g.vertex(4), g.vertex(6))
g.connect_vertex(g.vertex(5), g.vertex(6))
g.connect_vertex(g.vertex(6), g.vertex(15))
g.connect_vertex(g.vertex(4), g.vertex(11))
g.connect_vertex(g.vertex(11), g.vertex(12))
g.connect_vertex(g.vertex(11), g.vertex(13))
g.connect_vertex(g.vertex(13), g.vertex(14))
g.connect_vertex(g.vertex(12), g.vertex(14))

g.connect_vertex(g.vertex(7), g.vertex(8))
g.connect_vertex(g.vertex(7), g.vertex(9))
g.connect_vertex(g.vertex(9), g.vertex(10))
print("")
print("Print anterior a busca")
g.print()
g.DFS()
print("Print depois da busca")
g.print()

"""Exemplo 2: Grafo da figura indicada em: https://images.app.goo.gl/p3gkenZq1s6tRKVW7"""

g = Graph(digraph = False)
g.add_vertex() 
g.add_vertex()
g.add_vertex()
g.add_vertex()
g.add_vertex()
g.add_vertex()
g.add_vertex()
g.connect_vertex(g.vertex(0), g.vertex(1))
g.connect_vertex(g.vertex(0), g.vertex(2))
g.connect_vertex(g.vertex(2), g.vertex(1))
g.connect_vertex(g.vertex(1), g.vertex(6))
g.connect_vertex(g.vertex(1), g.vertex(3))
g.connect_vertex(g.vertex(3), g.vertex(5))
g.connect_vertex(g.vertex(5), g.vertex(4))
g.connect_vertex(g.vertex(4), g.vertex(1))
print("")
print("Print anterior a busca")
g.print()
g.DFS()
print("Print depois da busca")
g.print()